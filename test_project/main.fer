import "test_project/utils";
import "std/math";

// Unicode test: ä½ å¥½ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ ì•ˆë…•í•˜ì„¸ìš” ðŸš€ âœ…
/* Multi-line comment with Unicode:
 * Chinese: ä¸­æ–‡æµ‹è¯•
 * Japanese: æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ
 * Korean: í•œêµ­ì–´ í…ŒìŠ¤íŠ¸
 * Emoji: ðŸŽ‰ ðŸŒ ðŸ’» âœ¨
 */

let x := 42;
const PI := 3.14;

// Unicode in strings
let greeting: str = "Hello ä¸–ç•Œ! ðŸŒ";
let chinese: str = "ä½ å¥½ï¼Œè¿™æ˜¯ä¸­æ–‡";
let japanese: str = "ã“ã‚“ã«ã¡ã¯ã€æ—¥æœ¬èªžã§ã™";
let korean: str = "ì•ˆë…•í•˜ì„¸ìš”, í•œêµ­ì–´ìž…ë‹ˆë‹¤";
let emoji: str = "ðŸŽ‰ ðŸš€ âœ¨ ðŸ’» âœ… âŒ ðŸ”¥ ðŸ’¯";
let mixed: str = "Multi-language: English ä¸­æ–‡ æ—¥æœ¬èªž í•œêµ­ì–´ with emoji ðŸŒŸ";

// Byte literals (ASCII only)
let ascii_a: byte = 'A';
let ascii_z: byte = 'z';
let ascii_0: byte = '0';
let byte_newline: byte = '\n';
let byte_tab: byte = '\t';
let byte_escape: byte = '\\';

struct{
    .x: i32,
    .y: i32,
};

//import "s";

fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

let result := add(10, 20);

let name : i32 = utils::NAME;

let point := { .x = 1, .y = 2 } as utils::Point;

// add methods on Point
fn (p: utils::Point) normalize() {
    // manual math operation without using std/math by using ** operator
    let length := (p.x ** 2 + p.y ** 2) ** 0.5;
    p.x = p.x / length;
    p.y = p.y / length;
}

point.move(5, 10);
point.normalize();
point.notExist();

type Direction enum {
    North,
    East,
    South,
    West
};

let dir : i32 = enum{UP, DOWN}::East;