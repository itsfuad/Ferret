import "test_project/utils";

import "std/math";

// Unicode test: ä½ å¥½ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ ì•ˆë…•í•˜ì„¸ìš” ðŸš€ âœ…
/* Multi-line comment with Unicode:
 * Chinese: ä¸­æ–‡æµ‹è¯•
 * Japanese: æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ
 * Korean: í•œêµ­ì–´ í…ŒìŠ¤íŠ¸
 * Emoji: ðŸŽ‰ ðŸŒ ðŸ’» âœ¨
 */

let x := 42;
const PI := 3.14;

// Unicode in strings
let greeting: str = "Hello ä¸–ç•Œ! ðŸŒ";
let chinese: str = "ä½ å¥½ï¼Œè¿™æ˜¯ä¸­æ–‡";
let japanese: str = "ã“ã‚“ã«ã¡ã¯ã€æ—¥æœ¬èªžã§ã™";
let korean: str = "ì•ˆë…•í•˜ì„¸ìš”, í•œêµ­ì–´ìž…ë‹ˆë‹¤";
let emoji: str = "ðŸŽ‰ ðŸš€ âœ¨ ðŸ’» âœ… âŒ ðŸ”¥ ðŸ’¯";
let mixed: str = "Multi-language: English ä¸­æ–‡ æ—¥æœ¬èªž í•œêµ­ì–´ with emoji ðŸŒŸ";

// Byte literals (ASCII only)
let ascii_a: byte = 'A';
let ascii_z: byte = 'z';
let ascii_0: byte = '0';
let byte_newline: byte = '\n';
let byte_tab: byte = '\t';
let byte_escape: byte = '\\';

struct{
    .x: i32,
    .y: i32,
};

//import "s";

fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

let result := add(10, 20);

let name : i32 = utils::NAME;

let point := { .x = 1, .y = 2 } as utils::Point;

// add methods on Point
fn (p: utils::Point) normalize() {
    // manual math operation without using std/math by using ** operator
    let length := (p.x ** 2 + p.y ** 2) ** 0.5;
    p.x = p.x / length;
    p.y = p.y / length;
}

point.move(5, 10);
point.normalize();
point.notExist();

type Direction enum {
    North,
    East,
    South,
    West
};

let dir : i32 = enum{UP, DOWN}::East;

// Error/sucess type
// The T ! E is only usable with functions or methods that can return errors
fn divide(a: i32, b: i32) -> i32 ! str { // the str is the error type and i32 is the success type
    if b == 0 {
        return "Division by zero"!; // the `!` operator creates an error value. Its just a sugar for the error type. Actual type is string
    }
    return a / b; // normal return for success value (i32)
}

// Fixed: Added catch to handle the error
let divisionResult := divide(10, 0) catch 0; // Now properly handles the error with fallback

let divisionResult2 := divide(10, 2) catch err {
    // we may do something with the error here. err is of type str here as declared in the function signature
    return; // early return from the current function, divisionResult2 will be unknown but as we returned early, its ok as we won't use it

    // but if we do not return early, we must provide a value for divisionResult2
} 0 ; // this 0 or the default value of type i32 will be used if there was an error. Its mandatory to provide a default value if we do not return early. But can be just }; // if we returned earlyt. Here we used 0, but it can be any i32 value

// shorthand error handling

let divisionResult3 := divide(20, 4) catch 1; // if there was an error, 1 will be used as the default value