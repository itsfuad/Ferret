// Test type sizes for f128 and f256
// f32  = 4 bytes (32 bits)
// f64  = 8 bytes (64 bits)
// f128 = 16 bytes (128 bits)
// f256 = 32 bytes (256 bits)

fn demonstrate_float_range() {
    // f32: ~7 decimal digits precision
    let small: f32 = 3.14159;
    
    // f64: ~15-16 decimal digits precision
    let medium: f64 = 3.141592653589793;
    
    // f128: ~34 decimal digits precision
    let large: f128 = 3.14159265358979323846;
    
    // f256: ~71 decimal digits precision - fits exactly
    let huge: f256 = 3.1415926535897932384626433832795028841971693993751058209749445923078164;
    
    // This should fail - 65 digits in f32 (only ~7 digits supported)
    let overflow_f32: f32 = 3.1415926535897932384626433832795028841971693993751058209749445;
    
    // This should fail - 20 digits in f64 (only ~16 digits supported)
    let overflow_f64: f64 = 3.14159265358979323846;
}

fn demonstrate_conversions() {
    // All of these are lossless conversions (widening)
    let f32_val: f32 = 1.5;
    let to_f64: f64 = f32_val;     // 32 -> 64 bits
    let to_f128: f128 = f32_val;   // 32 -> 128 bits
    let to_f256: f256 = f32_val;   // 32 -> 256 bits
    
    let f64_val: f64 = 2.5;
    let f64_to_f128: f128 = f64_val;  // 64 -> 128 bits
    let f64_to_f256: f256 = f64_val;  // 64 -> 256 bits
    
    let f128_val: f128 = 3.5;
    let f128_to_f256: f256 = f128_val; // 128 -> 256 bits
}

fn main() {
    demonstrate_float_range();
    demonstrate_conversions();
}
