// Test file for function call validation

// Test 1: Regular function with correct args
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

let addResult := add(10, 20); // OK

// Test 2: Wrong argument count
let wrong1 := add(10); // ERROR: expected 2 arguments, found 1
let wrong2 := add(10, 20, 30); // ERROR: expected 2 arguments, found 3

// Test 3: Wrong argument types
let wrong3 := add(3.14, 2.71); // ERROR: type mismatch (f64 vs i32)
let wrong4 := add("hello", "world"); // ERROR: type mismatch (str vs i32)

// Test 4: Variadic function
fn sumAll(nums: ...i32) -> i32 {
    return 0;
}

let s1 := sumAll(); // OK - zero variadic args
let s2 := sumAll(1); // OK - one arg
let s3 := sumAll(1, 2, 3, 4, 5); // OK - multiple args

// Test 5: Variadic with required params
fn format(prefix: str, nums: ...i32) -> str {
    return prefix;
}

let f1 := format("Numbers: "); // OK - required + zero variadic
let f2 := format("Numbers: ", 1, 2, 3); // OK
let f3 := format(); // ERROR: expected at least 1 argument, found 0
let f4 := format(42, 1, 2); // ERROR: type mismatch in 'prefix' (i32 vs str)

// Test 6: Calling non-function
const PI := 3.14;
let bad := PI(); // ERROR: cannot call non-function (f64 is not callable)

// Test 7: Type inference in arguments
fn identity(x: i32) -> i32 {
    return x;
}

let inf1 := identity(42); // OK - untyped literal to i32
let inf2 := identity(10 + 20); // OK - inferred as i32
