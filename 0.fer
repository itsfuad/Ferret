import "Ferret/exp" as e;

let sum := 10 + 5;          // 15
let difference := 10 - 5;   // 5
let product := 10 * 5;      // 50
let quotient := 10 / 5;     // 2
let remainder := 10 % 3;    // 1 (10 divided by 3 is 3 remainder 1)
let power := 2 ** 4;

let a : str = "hi";

fn add(a: i32, b: str) -> i32 {
    //let x : i32 = b;
    return a + b;
}

add(23, 56, 10); // Error: cannot add i32 and str

//let pi : f32 = math::PI

e::ExportedNamwe;

let s : str = 10;

let int := 10;

let string : str = int;

// 128-bit integers
let huge: i128 = 170141183460469231731687303715884105727;  // 2^127 - 1
let big_unsigned: u128 = 340282366920938463463374607431768211455;

// 256-bit integers  
let massive: i256 = 578960446186580977117854925043439539266;  // 2^255 - 1
let enormous: u8 = 115792089237316195423570985008687907853;  // 2^256 - 1

enormous = "2";

// Works with hex notation too
let hex_val: i128 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

let sixTeefour : i64 = 64;
let another : i32 = sixTeefour;

// fn printf(fmt: str, args:... interface{}) {

// }

// printf();
// printf("no args");
// printf("one arg: {}", 42);
// printf("multiple args: {}, {}, {}", 1, "two", 3.0);

type Point struct {
    .x: f64,
    .y: f64,
};

let p := { .x = 3.0, .p = 1.2 } as Point;

let pp : i32 = p.x;

let valueFromLiteral : i8 = { .x = 5.0, .y = 10.0 }.z;

// should work
fn (p: Point) move(dx: f64, dy: f64, p: i32) -> Point {
    let new_point := { .x = p.x + dx, .y = p.y + dy } as Point;
    return new_point;
}

fn movePoint(p: Point, dx: f64, dy: f64) {
    // try to access private field (should error)
    let val := p.s;
}

// Method on anonymous struct (should error)
fn (p: Point) magnitude() -> f64 {
    return p.x * p.x + p.y * p.s;
}

let newPoint : i32 = p.move(1, 2, 3);

