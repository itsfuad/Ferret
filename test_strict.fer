// Test strict type checking with explicit casts

import "std/io";

fn main() {
    io::Println("=== Strict Type Checking Demo ===\n");
    
    // Different sized integers require explicit casting
    let small: i32 = 100;
    let big: i256 = 340282366920938463463374607431768211456;
    
    // This would error: let result := small + big;
    // Error: mismatched types in arithmetic: i32 and i256
    
    // Correct way: explicit cast to the larger type
    let result := (small as i256) + big;
    io::Print("i32 cast to i256, then add: ");
    io::Println(result);
    
    // Or cast down (with potential overflow)
    let result2 := small + (big as i32);  // Truncates big to i32
    io::Print("i256 cast to i32 (truncated), then add: ");
    io::Println(result2);
    
    // Same applies to all arithmetic operators
    let a: i64 = 1000;
    let b: i128 = 170141183460469231731687303715884105727;
    
    // Multiplication requires matching types
    let product := (a as i128) * b;
    io::Print("\ni64 * i128 (with cast): ");
    io::Println(product);
    
    // Division
    let quotient := b / (a as i128);
    io::Print("i128 / i64 (with cast): ");
    io::Println(quotient);
    
    // Float and int mixing also requires cast
    let integer: i32 = 42;
    let floating: f64 = 3.14159;
    
    // This would error: let sum := integer + floating;
    let sum := (integer as f64) + floating;
    io::Println("\ni32 cast to f64, then add: ", sum);
    
    // Different float sizes also require casting
    let f32val: f32 = 3.14;
    let f64val: f64 = 2.718281828;
    
    // This would error: let result := f32val + f64val;
    let floatSum := (f32val as f64) + f64val;
    io::Println("f32 cast to f64, then add: ", floatSum);
    
    io::Println("\n=== All operations successful with explicit casts! ===");
}
