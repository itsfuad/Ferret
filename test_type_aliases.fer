// Test type aliases and nested aliases

type Int i32;
type MyInt Int;
type AnotherInt MyInt;

let a : Int = 42;
let b : MyInt = 100;
let c : AnotherInt = 200;

// These should fail - nominal typing
// let x : i32 = a;  // Error: cannot use Int as i32
// let y : Int = b;  // Error: cannot use MyInt as Int

type Point struct {
    .x: i32,
    .y: i32,
};

type Point2D Point;
type Coordinate Point2D;

let p1 : Point = { .x = 1, .y = 2 } as Point;
let p2 : Point2D = { .x = 3, .y = 4 } as Point2D;
let p3 : Coordinate = { .x = 5, .y = 6 } as Coordinate;

// Methods should work through aliases
fn (p: Point) distance() -> i32 {
    return p.x + p.y;
}

p1.distance();
