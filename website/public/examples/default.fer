
// Test 1: Lossless widening conversion (should work)
let a: i32 = 10;
let b: i64 = a;  // OK: i32 to i64 is lossless

// Test 2: Lossy conversion (should error with helpful message)
let c: i64 = 1000000;
let d: i32 = c;  // Error: requires explicit cast
let a : str = "hi"; // Error: redeclaration

// Test 3: UNTYPED literal contextualization
let e: i8 = 100;  // OK: literal 100 fits in i8
let f: i8 = 200;  // Error: 200 doesn't fit in i8 (-128 to 127)

// Test 4: Binary expression with mixed types
let g: i32 = 10;
let h: i64 = 20;
let i := g + h;  // OK: result is i64 (wider type)

// Test 5: Incompatible types
let s: str = "hello";
let n: i32 = 42;
let bad := s + n;  // Error: cannot add str and i32