---
title: "Ferret to Binary: A Deep Architectural Walkthrough"
description: "Phase graphs, shared context, HIR/CFG reasoning, and runtime integration for Ferret's .fer -> C -> binary pipeline."
pubDate: 2025-12-16
tags: [ferret, compiler, architecture]
---

This is a detailed map of Ferret's compiler architecture aimed at compiler engineers. It focuses on:

- How phases communicate through a shared compiler context.
- How modules are scheduled, resolved, and type-checked.
- How HIR/CFG analysis fits into the pipeline.
- How codegen and the runtime cooperate (includes, helpers, formatting).
- Determinism and failure modes.

## Complete System Architecture

The Ferret compiler follows a multi-phase pipeline architecture where modules progress through compilation phases independently. The central `CompilerContext` coordinates all phases and maintains shared state. This diagram shows the complete end-to-end flow from source files to executable binary.

```d2
source: ".fer source files" {
  style.fill: "#e3f2fd"
  style.stroke: "#1976d2"
  style.stroke-width: 3
}

compiler: {
  # Central CompilerContext - compact hub in center
  context: CompilerContext {
    style.fill: "#fff3e0"
    style.stroke: "#f57c00"
    style.stroke-width: 4
    style.border-radius: 8
    
    modules: "Modules Map"
    depgraph: "Dependency Graph"
    diagnostics: "DiagnosticBag"
    universe: "Universe Scope"
    topoorder: "Topological Order"
    
    modules -> depgraph -> topoorder
    diagnostics.style.fill: "#ffebee"
    universe.style.fill: "#e8f5e9"
  }
  
  phase1_parse: {
    label: "Phase 1: Parse"
    style.fill: "#e1f5fe"
    style.stroke: "#0277bd"
    
    processmodule: "processModule()\nsync.Map dedup"
    seenmap: "sync.Map\nseen guard"
    goroutines: {
      goroutine: "Goroutine\n(per module)" {
        style.multiple: true
      }
    }
    fileops: {
      readfile: "Read File"
      resolvepath: "Resolve Path\n(local/builtin/remote)" {
        nativecheck: "native://?"
        emptyast: "Empty AST"
        advancephase: "PhaseParsed"
        
        nativecheck -> emptyast -> advancephase
      }
    }
    lexparse: {
      lexer: "Lexer\nTokenize"
      parser: "Parser\nAST"
      updatemodule: "Lock Module.Mu"
      setphase: "Set Phase"
      storeast: "Store AST"
      
      lexer -> parser
      updatemodule -> setphase -> storeast
    }
    imports: {
      extract: "Extract Imports\n(top-level)"
      adddep: "Add to DepGraph"
    }
    coordination: {
      waitgroup: "WaitGroup\ncoordinate"
      topoorder: "Compute Topo\nOrder"
      
      waitgroup -> topoorder: "Wait()"
    }
    
    processmodule -> seenmap: "LoadOrStore"
    seenmap -> goroutines.goroutine: "when new"
    goroutines.goroutine -> fileops.readfile -> fileops.resolvepath -> lexparse.lexer
    lexparse.parser -> imports.extract -> imports.adddep
    imports.adddep -> processmodule: "recursive"
    goroutines.goroutine -> coordination.waitgroup: "Done()"
    coordination.topoorder -> context.topoorder: "compute"
    lexparse.parser -> context.modules: "store AST"
    imports.adddep -> context.depgraph: "add edges"
  }
  
  phase2_collect: {
    label: "Phase 2: Collect"
    style.fill: "#f3e5f5"
    style.stroke: "#7b1fa2"
    
    collector: "Collector\n(traverse AST)"
    declaration: {
      types: "Declare Types\n(structs, enums)"
      funcs: "Declare Functions\n(signatures)"
      variables: "Declare Variables\n(module-level)"
    }
    modulescope: "ModuleScope\nSymbol Table" {
      scopes: {
        universe: "Universe\n(built-ins)"
        module: "Module Scope"
        function: "Function Scope"
        block: "Block Scope"
        
        universe -> module: "parent"
        module -> function: "parent"
        function -> block: "parent"
      }
    }
    
    collector -> declaration.types -> modulescope
    collector -> declaration.funcs -> modulescope
    collector -> declaration.variables -> modulescope
    modulescope.scopes.universe -> context.universe: "root"
  }
  
  phase3_resolve: {
    label: "Phase 3: Resolve"
    style.fill: "#fff9c4"
    style.stroke: "#f57f17"
    
    resolver: "Resolver\n(walk AST)"
    bindnames: "Bind Identifiers\nto Symbols"
    resolveimports: "Resolve Import\nReferences"
    boundast: "Bound AST\n(annotated)"
    
    resolver -> bindnames -> boundast
    resolver -> resolveimports -> boundast
    bindnames -> context.diagnostics: "missing symbol"
    resolveimports -> context.diagnostics: "import error"
  }
  
  phase4_typecheck: {
    label: "Phase 4: Type Check"
    style.fill: "#e8f5e9"
    style.stroke: "#388e3c"
    
    methodsigs: "Method Signatures\n(attach to types)"
    methodset: "Build Method Sets\n(for interfaces)"
    typechecker: "Type Checker\n(validate semantics)"
    checks: {
      exprs: "Check Expressions\n(type inference)"
      calls: "Check Function Calls\n(signature match)"
      methods: "Check Method Calls\n(receiver types)"
      interfaces: "Check Interface\nImplementations"
      optionals: "Check Optional\nUnwrapping"
      maps: "Check Map\nOperations"
    }
    typedast: "Typed AST\n(type annotations)"
    
    methodsigs -> methodset
    methodset -> checks.interfaces
    typechecker -> checks.exprs -> typedast
    typechecker -> checks.calls -> typedast
    typechecker -> checks.methods -> typedast
    typechecker -> checks.interfaces
    typechecker -> checks.optionals
    typechecker -> checks.maps
    checks.exprs -> context.diagnostics: "type error"
    checks.interfaces -> context.diagnostics: "type error"
  }
  
  phase5_hir: {
    label: "Phase 5: HIR Gen"
    style.fill: "#e0f7fa"
    style.stroke: "#00838f"
    
    hirgen: "HIR Gen\n(AST -> HIR)"
    hirmodule: "HIR Module\n(source-shaped)"
    
    hirgen -> hirmodule
  }
  
  phase6_cfg: {
    label: "Phase 6: HIR CFG"
    style.fill: "#fce4ec"
    style.stroke: "#c2185b"
    
    cfganalyzer: "HIR CFG Analyzer\n(per module)"
    buildcfg: "BuildFunctionCFG\n(per function)"
    structure: {
      entryblock: "Entry Block\n(function start)"
      statementblocks: "Statement Blocks\n(sequential)"
      branchblocks: "Branch Blocks\n(if/while/for)"
      exitblock: "Exit Block\n(function end)"
      
      entryblock -> statementblocks
      statementblocks -> branchblocks
      branchblocks -> exitblock: "normal flow"
      branchblocks -> branchblocks: "loops"
    }
    analysis: {
      unreachable: "Detect Unreachable\nCode"
      missingreturn: "Check Missing\nReturns"
      breakcontinue: "Validate Break/\nContinue"
      allpathsreturn: "All Paths Return\nCheck"
    }
    errorcheck: "HasErrors()\ncheck"
    skipcodegen: "Skip Codegen\nwhen errors"
    proceedcodegen: "Proceed to\nHIR lowering"
    
    cfganalyzer -> buildcfg
    buildcfg -> structure.entryblock
    structure.exitblock -> analysis.allpathsreturn
    analysis.unreachable -> context.diagnostics: "unreachable"
    analysis.missingreturn -> context.diagnostics: "missing returns"
    analysis.breakcontinue -> context.diagnostics: "invalid control flow"
    context.diagnostics -> errorcheck
    errorcheck -> skipcodegen: "errors found"
    errorcheck -> proceedcodegen: "no errors"
  }
  
  phase7_lowering: {
    label: "Phase 7: HIR Lowering"
    style.fill: "#ede7f6"
    style.stroke: "#5e35b1"
    
    lower: "Lower HIR\n(desugar/normalize)"
    lowered: "Lowered HIR"
    
    lower -> lowered
  }
  
  phase8_codegen: {
    label: "Phase 8: Codegen"
    style.fill: "#e0f2f1"
    style.stroke: "#00695c"
    
    codegen: "Codegen\n(emit C, AST-backed today)"
    includes: {
      includesgo: "includes.go\n(single source)"
      standard: "Standard\nincludes"
      runtime: "Runtime\nincludes"
      
      includesgo -> standard
      includesgo -> runtime
    }
    generation: {
      header: "Generate\n.h files"
      impl: "Generate\n.c files"
      
      includes.standard -> header
      includes.runtime -> header
      includes.standard -> impl
      includes.runtime -> impl
    }
    format: "Format C\n(indent)"
    ccode: "Generated C\n(.c/.h files)"
    
    codegen -> includes.includesgo
    generation.header -> format
    generation.impl -> format
    format -> ccode
  }
  
  runtime: "Runtime System" {
    style.fill: "#f1f8e9"
    style.stroke: "#558b2f"
    
    headers: "runtime/*.h\n(optional.h, map.h,\ninterface.h, io.h,\nbigint.h)" {
      style.multiple: true
    }
    impl: "runtime/*.c\n(implementations)" {
      style.multiple: true
    }
    
    headers -> impl
  }
  
  build: {
    label: "Build System"
    style.fill: "#fff8e1"
    style.stroke: "#f9a825"
    
    cc: "cc/clang\ncompile" {
      compile: "Compile .c"
      objectfiles: ".o files" {
        style.multiple: true
      }
      
      compile -> objectfiles
    }
    linker: "Linker" {
      linkruntime: "Link runtime"
      linkmodules: "Link modules"
      
      linkruntime -> linkmodules
    }
  }
  
  binary: "Executable" {
    style.fill: "#e8eaf6"
    style.stroke: "#3f51b5"
    style.stroke-width: 3
  }
  
  # Main compilation flow (horizontal pipeline)
  source -> phase1_parse.processmodule
  phase1_parse.coordination.topoorder -> phase2_collect.collector: "topo order"
  phase2_collect.modulescope -> phase3_resolve.resolver: "symbols"
  phase3_resolve.boundast -> phase4_typecheck.typechecker: "bound AST"
  phase4_typecheck.typedast -> phase5_hir.hirgen: "typed AST"
  phase5_hir.hirmodule -> phase6_cfg.cfganalyzer: "HIR"
  phase6_cfg.proceedcodegen -> phase7_lowering.lower: "HIR"
  phase7_lowering.lowered -> phase8_codegen.codegen: "lowered HIR"
  phase8_codegen.ccode -> runtime -> build.cc -> build.linker -> binary
  
  # Context in center - compact box connecting all phases
  # Context feeds phases (outgoing connections)
  context.modules -> phase1_parse.processmodule: "modules"
  context.topoorder -> phase2_collect.collector: "topo order"
  context.universe -> phase4_typecheck.typechecker: "universe"
  context -> phase1_parse: "config & modules"
  context -> phase2_collect: "topo order"
  context -> phase3_resolve: "symbols"
  context -> phase4_typecheck: "universe"
  context -> phase5_hir: "typed AST"
  context -> phase6_cfg: "HIR"
  context -> phase7_lowering: "HIR"
  context -> phase8_codegen: "typed AST (current backend)"
  
  # Error feedback to context (incoming connections - all phases report)
  phase1_parse.lexparse.parser -> context.diagnostics: "parse errors"
  phase2_collect.collector -> context.diagnostics: "collect errors"
  phase3_resolve.resolver -> context.diagnostics: "resolve errors"
  phase4_typecheck.typechecker -> context.diagnostics: "type errors"
  phase6_cfg.cfganalyzer -> context.diagnostics: "HIR CFG errors"
  
  # Data updates to context
  phase1_parse.lexparse.parser -> context.modules: "store AST"
  phase1_parse.imports.adddep -> context.depgraph: "add edges"
  phase1_parse.coordination.topoorder -> context.topoorder: "compute"
  
  # Runtime integration
  phase8_codegen.includes.runtime -> runtime.headers: "includes"
  build.cc.compile -> build.linker.linkruntime: "object files"
  runtime.impl -> build.linker.linkruntime: "runtime objects"
}
```

Key architectural principles:

- **Parallel parsing**: Modules are parsed concurrently using goroutines with `sync.Map` for deduplication and `sync.WaitGroup` for coordination.
- **Shared context**: `CompilerContext` maintains all shared state (modules, diagnostics, universe, dependency graph) with proper locking.
- **Per-module phases**: Each module tracks its own compilation phase independently, enabling incremental compilation.
- **Monotonic progression**: Modules advance through phases sequentially; errors stop progression but don't backtrack.
- **Externalized runtime**: Runtime helpers live in `runtime/` directory; codegen emits includes via `includes.go`.
- **Error accumulation**: All phases collect errors in `DiagnosticBag`; compilation continues to find all errors, not just the first.
- **Deterministic output**: Topological ordering, stable include lists, and consistent naming ensure reproducible builds.

## Phase Details

### Phase 1: Parallel Parsing

- **Deduplication**: `sync.Map` ensures `processModule()` schedules parsing exactly once per import path.
- **Concurrency**: Each module spawns its own goroutine; `sync.WaitGroup` coordinates completion.
- **Top-level imports only**: Only imports at the top of the file are processed; parsing stops at first non-import declaration.
- **Dependency tracking**: Each import is added to `DepGraph` for cycle detection and topological ordering.
- **Native modules**: Built-in modules (`native://...`) skip lex/parse but advance phase markers to maintain DAG coherence.
- **Phase advancement**: Modules progress from `PhaseNotStarted` → `PhaseLexed` → `PhaseParsed` with prerequisite checks.

### Phase 2: Symbol Collection

- **Two-phase collection**: First pass declares all symbols (types, functions, variables); second pass processes function bodies after all declarations are known.
- **Scope hierarchy**: Scopes form a tree rooted in the universe, with module → function → block scopes.
- **Topological processing**: Modules are processed in dependency order, ensuring imported symbols are available.

### Phase 3: Resolution

- **Name binding**: Identifiers are bound to their declarations in symbol tables.
- **Import resolution**: Imports are resolved using the dependency graph; module aliases enable `Module::Symbol` access.
- **Error reporting**: Missing or ambiguous symbols are reported via diagnostics with source locations.

### Phase 4: Type Checking

- **Two-pass type checking**: Method signatures are checked first to build method sets, then full type checking proceeds.
- **Type inference**: Expression types are inferred from context (assignments, function calls, returns).
- **Interface validation**: Ensures types implement required methods with correct signatures.
- **Optional safety**: Validates that optionals are unwrapped before use.
- **Error accumulation**: All type errors are collected; codegen is skipped when errors exist.

### Phase 5: HIR Generation

- **AST → HIR**: Lower the typed AST into source-shaped HIR with stable node kinds.
- **Location fidelity**: Preserve source spans for precise diagnostics downstream.
- **Phase boundary**: HIR becomes the canonical input for CFG analysis and later lowering.

### Phase 6: HIR CFG Analysis

- **Per-function CFGs**: Each function gets its own control flow graph with entry, statement, branch, and exit blocks.
- **Unreachable detection**: Code after `return`, `break`, or `continue` is flagged as unreachable.
- **Return validation**: Functions with non-void return types must have returns on all paths.
- **Loop context**: Tracks nested loops for `break`/`continue` validation.
- **Codegen gate**: Code generation is skipped when HIR CFG analysis finds errors.

### Phase 7: HIR Lowering

- **Desugaring**: Normalize optional/result/catch syntax into lowered forms for MIR/codegen.
- **Simplification**: Reduce surface constructs into fewer core HIR forms.
- **Backend prep**: Establishes a stable, lowered IR for MIR and target backends.

### Phase 8: Code Generation

- **Single source of truth**: `includes.go` centralizes all runtime header includes, ensuring consistency.
- **Deterministic output**: Stable include order and naming make generated code predictable and diff-friendly.
- **External runtime**: Runtime helpers live in `runtime/` directory; codegen only emits includes, not implementations.
- **Separate formatting**: C formatting is a post-processing step, keeping codegen logic simple.
- **Module headers**: Each module generates its own `.h` and `.c` files; modules include each other's headers.
- **Build integration**: Generated C is compiled and linked with runtime sources to produce the final executable.
- **Current backend note**: The C backend still consumes the typed AST while HIR lowering is bootstrapped for MIR/backends.

## How to Exercise the Pipeline

The compiler provides several flags for inspecting the compilation process:

```bash
# Build the compiler
go build -o bin/ferret

# Compile with debug output (shows all phases)
ferret -d -o app Hello/main.fer

# Keep generated C files for inspection
ferret -c -o app Hello/main.fer

# Keep and format generated C files
ferret -cfc -o app Hello/main.fer

# Stop after type checking (skip codegen)
ferret -t Hello/main.fer

# Run the executable
./app
```

Useful debugging techniques:

- **`-d` (debug)**: Shows phase progression and module processing order.
- **`-c` / `-keep-c`**: Preserves generated C files in `bin/gen/` for inspection.

- **`-t` (typecheck)**: Stops after type checking to validate semantics without codegen.
- **Diagnostics**: All errors are collected in `CompilerContext.Diagnostics` with source locations.

## Design Principles

- **Narrow phases**: Each stage does one job (collect symbols, check types, build HIR CFG) and doesn't redo previous work.
- **Shared context**: Modules, diagnostics, topo order, and universe types live in one place; phases consume and enrich it.
- **Runtime-first**: Feature logic (optionals, maps, interfaces) is centralized in `runtime/`; codegen only wires types to these helpers.
- **Deterministic output**: Stable emission and formatting reduce friction for users and for compiler development.
- **Monotonic phases**: Modules advance through phases sequentially; no backtracking or phase reuse across runs.
- **Prerequisite checking**: `PhasePrerequisites` map enforces phase ordering (e.g., `PhaseResolved` requires `PhaseCollected`).
- **Thread-safe diagnostics**: `DiagnosticBag` uses mutexes to safely collect errors from concurrent goroutines.
- **Graceful degradation**: Parse errors stop a module; semantic errors continue but skip codegen.
