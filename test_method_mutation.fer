type Counter struct {
    .value: i32,
};

// Mutating method - reference receiver
fn (c: &Counter) increment() {
    c.value = c.value + 1;
}

// Non-mutating method - value receiver
fn (c: Counter) getValue() -> i32 {
    return c.value;
}

fn main() {
    let arr: [10]i32 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    // Test 1: Using struct field as index
    let counter := { .value = 5 } as Counter;
    let x := arr[counter.value];  // Should work - value is 5
    
    // Test 2: After calling mutating method
    counter.increment();  // Modifies counter.value to 6
    let y := arr[counter.value];  // Is value still tracked as constant?
    
    // Test 3: Multiple increments
    counter.increment();
    counter.increment();  // counter.value is now 8
    let z := arr[counter.value];  // Should this work?
    
    // Test 4: After non-mutating method
    let val := counter.getValue();  // Returns 8
    let w := arr[val];  // Is val constant?
}
